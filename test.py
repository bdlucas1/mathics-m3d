import os
os.environ["MATHICS3_TIMING"] = "1"

import time
import pathlib
import copy

import panel as pn
import plotly
import plotly.io as pio
import plotly.graph_objects as go
import skimage.transform
import skimage.io
import PIL
import numpy as np
import cairosvg

import util

class State: pass
state = State()

state.pending = 0
state.run = 0
state.missing = 0
state.failed = 0
state.passed = 0
state.fixed = 0

def summarize_and_exit():
    msg = f"=== {state.run} run, {state.passed} passed, {state.failed} failed, {state.fixed} fixed"
    print(msg)
    msg = pn.widgets.StaticText(value=msg)
    state.top[:] = [x for x in state.top if not isinstance(x, pn.widgets.Button)] + [msg]
    time.sleep(1)
    os._exit(0)

state.top = pn.Column(
    heading := pn.pane.Str("Running tests "),
    styles={"gap": "1em"}
)
util.show(state.top, "TEST", browser="webbrowser")

# track pending tests so we know when we're done
def pending():
    state.pending += 1

def test(test_info, layout, expr):

    # do it up front in case we return early as this is used
    # to know when we are done
    state.pending -= 1

    fn = test_info["fn"]
    test_name = test_info["test"]

    # compute test filename fn
    if test_name := test_info["test"]:
        base_fn, _ =  os.path.splitext(fn)
        fn = f"{base_fn}={test_name}" # = sorts after .
    else:
        # this was a freestanding .m file
        fn, _ = os.path.splitext(fn)

    print("=== TEST", fn) #, layout)
    heading.object += "."
    state.run += 1

    # file names
    path = pathlib.Path(fn)
    fn_png_ref = path.parent / "@ref" / (path.name + ".png")
    fn_png_act = f"/tmp/{fn.replace('/','-')}.png"
    # not in use - going straight to .svg.png
    #fn_svg_ref = path.parent / "@ref" / (path.name + ".svg")
    #fn_svg_act = f"/tmp/{fn.replace('/','-')}.svg"
    fn_svg_png_ref = path.parent / "@ref" / (path.name + ".svg.png")
    fn_svg_png_act = f"/tmp/{fn.replace('/','-')}.svg.png"
    fn_dump = f"/tmp/{fn.replace('/','-')}.txt"

    # dump expr for debugging
    with open(fn_dump, "w") as f:
        try:
            util.print_expression_tree(expr, file=f, approximate=True)
        except Exception as oops:
            print(f"dumping to {fn_dump} got exception {oops}")

    # get figures - pio.write_image only works with Figures
    def collect_figures(x):
        if isinstance(x, go.Figure):
            yield x
        elif isinstance(x, pn.pane.Plotly):
            yield x.object
        else:
            try:
                for xx in x:
                    if xx is not x:
                        yield from collect_figures(xx)
            except TypeError as oops:
                #print(oops)
                pass

    mode = test_info.get("mode", "figure")
    if mode == "figure":

        # find a figure and write it
        collect_figures(layout)
        figures = [*collect_figures(layout)]
        if len(figures) == 0:
            state.failed += 1
            print("NO FIGURES")
            return

        # write only last figure
        figure = figures[-1] # mimic previous behavior
        if not figure:
            print("FAIL: figure is None")
            return
        pio.write_image(figure, fn_png_act) # only works for Figures

    elif mode == "layout":

        # save entire layout
        # hack: this cuts off a bit of the right side, so we pad it
        hack = pn.Row(layout, pn.Spacer(width=100))
        hack.save(fn_png_act)

    # compare the pngs generated by m3d plotly, panel
    compare(fn_png_act, fn_png_ref)

    # try to generate svg using mathics.core and compare with ref
    try:
        # about 10 ms, so no reason not to go straight to png, simplifying
        svg_act = layout._m3d_boxed.boxes_to_svg()
        os.remove(fn_svg_png_act)
        cairosvg.svg2png(
            bytestring=svg_act.encode('utf-8'),
            write_to=fn_svg_png_act,
            background_color="white"
        )
    except Exception as oops:
        print(f"can't generate svg {fn_svg_png_act}: {oops}")

    if os.path.exists(fn_svg_png_act) or os.path.exists(fn_svg_png_ref):
        compare(fn_svg_png_act, fn_svg_png_ref)
    

def compare(fn_png_act, fn_png_ref):

    # function to wrap image together with caption in a column
    def img(cap, im):
        im = PIL.Image.fromarray(im)
        im = pn.pane.Image(im, width=im.width, sizing_mode='fixed')
        cap = pn.widgets.StaticText(value=cap)
        return pn.Column(cap, im)

    row, cap = None, None

    # read image back int
    try:
        img_act = skimage.io.imread(fn_png_act)[:,:,0:3]
    except Exception as e:
        img_act = None

    # let's see what happened
    if img_act is None:
        print(f"couldn't generate {fn_png_act}")
        state.failed += 1
    elif not os.path.exists(fn_png_ref):
        print(f"=== ref image {fn_png_ref} does not exist")
        state.missing += 1
        row = pn.Row(img("actual", img_act))
        cap = f"Save test image as {fn_png_ref}"
    else:
        # ref image exists - compare
        img_ref = skimage.io.imread(fn_png_ref)[:,:,0:3]
        if img_act.shape != img_ref.shape:
            print(f"=== shapes differ: test {img_act.shape}, ref {img_ref.shape}")
            state.failed += 1
            row = pn.Row(img("actual",img_act), img(f"expected {fn_png_ref}",img_ref))
            cap = "Update expected image"
        elif not (img_ref - img_act == 0).all():
            print("=== images differ")
            state.failed += 1
            im_diff = abs(img_act.astype(float) - img_ref.astype(float)) # avoid overflow
            print("max pixel diff", np.max(im_diff))
            im_diff = im_diff.astype(np.uint8)
            row = pn.Row(img("actual",img_act), img(f"expected {fn_png_ref}",img_ref), img("diff",im_diff))
            cap = "Update expected image"
        else:
            print("=== images are identical")
            state.passed += 1
        
    # if there was a diff show it and ask
    if row:
        button = pn.widgets.Button(name=cap, styles={"font-size": "12pt"})
        def copy(_):
            print(f"=== copying {fn_png_act} to {fn_png_ref}")
            state.fixed += 1
            with open(fn_png_act, "rb") as f_test:
                img_data = f_test.read()
                with open(fn_png_ref, "wb") as f_ref:
                    f_ref.write(img_data)
            state.top.remove(row)
            state.top.remove(button)
        button.on_click(copy)
        state.top.append(row)
        state.top.append(button)

    # if we've seen all tests we were promised and there were no failures just exit
    # otherwise the user will have to press the "Finish" button
    if state.pending == 0:
        if state.failed == 0 and state.missing == 0:
            summarize_and_exit()
        else:
            finish_button = pn.widgets.Button(name="Finish")
            finish_button.on_click(lambda _: summarize_and_exit())
            state.top.append(finish_button)
            print("=== there were failures - finish in browser window")
            

    # TODO: WIP
    # ff formats too wide, so fix that first
    #layout.save(f"/tmp/{fn_m.split('/')[-1]}-test.png")
    #


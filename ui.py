import time
import itertools

import panel as pn
import panel.io
import plotly.graph_objects as go
import bokeh.models

import layout as lt
import ui
import util


def wrap(s):
    return pn.widgets.StaticText(value=s)


def latex(s):
    if isinstance(s, str):
        return pn.pane.LaTeX(f"${s}$")
    return s


def row(ls):
    # TODO: look into baseline alignment
    items = [pn.widgets.StaticText(value=l) if isinstance(l, str) else l for l in ls]
    return pn.Row(*items)


def grid(grid_content):

    # this was automatically generated by ChatGPT translating the Dash version
    # TODO: look into alignment etc.

    n_rows = len(grid_content)
    n_cols = max(len(r) for r in grid_content) if n_rows > 0 else 0

    # Flatten children and convert strings
    children = []
    for r in grid_content:
        for cell in r:
            if isinstance(cell, str):
                children.append(pn.widgets.StaticText(value=cell))
            else:
                children.append(cell)

    # Panel GridBox uses ncols; we can approximate the same behavior
    gb = pn.GridBox(
        *children,
        ncols=n_cols,
        #sizing_mode="fixed",  # helps avoid over-expanding horizontally
    )
    gb.css_classes = ["m-grid"]

    # Wrap in a Row (similar to ipw.HBox) to keep width under control
    layout = pn.Row(gb)
    return layout


def graph(figure, height):

    plot = pn.pane.Plotly(
        figure,
        #config={"displayModeBar": False}, # TODO: do we still want this?
        height=int(height),
        css_classes = ["m-plot"]
    )
    return plot

    # TODO: look into plot baseline alignment
    #center_baseline = pn.Spacer(width=0, height=int(height / 2))
    #layout = pn.Row(center_baseline, plot)
    #return layout


def manipulate(init_target_layout, sliders, eval_and_layout):

    # wrap plotly figures in pn.pane.Plotly for more efficient updates
    # else just use a Column (TODO: any better way in this case?)
    def wrap(x):
        if isinstance(x, pn.pane.Plotly):
            return x
        elif isinstance(x, go.Figure):
            return pn.pane.Plotly(x)
        else:
            return pn.Column(x)

    # update the layout depending on how we wrapped it
    # and how we're updating it
    def update(x, v):
        if isinstance(x, pn.pane.Plotly):
            if isinstance(x, pn.pane.Plotly):
                x.object = v.object
            elif isinstance(v, go.Figure):
                x.object = v
        elif isinstance(x, pn.Column):
            x[0] = v

    # timer mechanism used to "debounce" slider
    # by setting this flag when an update is needed
    update_requested = False
    def request_update(event):
        nonlocal update_requested
        update_requested = True

    # and periodically doing this to update if requested
    # period can be tweaked for optimal responsiveness:
    # too long and updates will be sluggish, but also
    # too short and cpu is wasted so updates are sluggish
    # TODO: can we turn timer off when not needed so we don't
    # have constant stream of events?
    def update_if_requested(event=None):
        nonlocal update_requested
        if update_requested:
            update_requested = False
            with util.Timer("slider update"):
                values = [s.value for s in pn_sliders]
                target_layout = eval_and_layout(values)
                update(target, target_layout)
    try:
        timer = pn.state.add_periodic_callback(update_if_requested, period=100)
    except RuntimeError:
        # in test mode we can't do this because we're headless, and it wants a
        # running event loop, but in that case we can't move sliders either,
        # so just ignore
        pass
        
    # build sliders
    pn_sliders = []
    cells = []    
    def add_slider(s):
        label = pn.pane.Str(s.name)
        slider = pn.widgets.FloatSlider(
            name="",
            start=s.lo,
            end=s.hi,
            step=s.step,
            value=s.init,
            show_value=False,
            sizing_mode="stretch_width"
        )
        readout = pn.widgets.StaticText(value=f"{slider.value:.2f}")

        # keep target in sync with slider
        slider.param.watch(request_update, "value")

        # keep readout in sync with slider
        def update_readout(event):
            readout.value = f"{event.new:.2f}"
        slider.param.watch(update_readout, "value")

        # add to grid
        cells.extend([label, slider, readout])
        pn_sliders.append(slider)

    for s in sliders:
        add_slider(s)

    grid = pn.GridBox(
        *cells,
        ncols=3,
        sizing_mode="stretch_width",
        css_classes=["m-sliders"],
    )

    # wrap the layout for efficient update
    target = wrap(init_target_layout)

    # main layout: target on top, sliders below
    layout = pn.Column(
        target,
        grid,
        width_policy="min",
        css_classes = ["m-manipulate"]
    )

    return layout


# helper for defining buttons with tooltip descripton
# TODO: move to ui.py
def icon_button(icon, description, on_click):
    def tt():
        return bokeh.models.Tooltip(
            content=description,
            position="bottom",
            show_arrow=False
        )
    button = pn.widgets.ButtonIcon(
        icon = icon,
        description = tt(),
    )
    def intercept(event):
        on_click()
        # this seems to make the tooltip disappear if the button moves
        # otherwise the hover state of the tip doesn't change (html misfeature)
        button.description = tt()
    button.on_click(intercept)
    return button


#
# Following code is from https://github.com/holoviz/panel/issues/3193
#

from typing import TypedDict, NotRequired
from panel.custom import ReactComponent, DataEvent
import param
import panel as pn


# Note: this uses TypedDict instead of Pydantic or dataclass because Bokeh/Panel doesn't seem to
# like serializing custom classes to the frontend (and I can't figure out how to customize that).
class KeyboardShortcut(TypedDict):
    name: str
    key: str
    altKey: NotRequired[bool]
    ctrlKey: NotRequired[bool]
    metaKey: NotRequired[bool]
    shiftKey: NotRequired[bool]


class KeyboardShortcuts(ReactComponent):
    """
    Class to install global keyboard shortcuts into a Panel app.

    Pass in shortcuts as a list of KeyboardShortcut dictionaries, and then handle shortcut events in Python
    by calling `on_msg` on this component. The `name` field of the matching KeyboardShortcut will be sent as the `data`
    field in the `DataEvent`.

    Example:
    >>> shortcuts = [
        KeyboardShortcut(name="save", key="s", ctrlKey=True),
        KeyboardShortcut(name="print", key="p", ctrlKey=True),
    ]
    >>> shortcuts_component = KeyboardShortcuts(shortcuts=shortcuts)
    >>> def handle_shortcut(event: DataEvent):
            if event.data == "save":
                print("Save shortcut pressed!")
            elif event.data == "print":
                print("Print shortcut pressed!")
    >>> shortcuts_component.on_msg(handle_shortcut)
    """

    # bdl - following failed, but my change works
    #shortcuts = param.List(class_=dict)
    shortcuts = param.List()

    _esm = """
    // Hash a shortcut into a string for use in a dictionary key (booleans / null / undefined are coerced into 1 or 0)
    function hashShortcut({ key, altKey, ctrlKey, metaKey, shiftKey }) {
      return `${key}.${+!!altKey}.${+!!ctrlKey}.${+!!metaKey}.${+!!shiftKey}`;
    }

    export function render({ model }) {
      const [shortcuts] = model.useState("shortcuts");

      const keyedShortcuts = {};
      for (const shortcut of shortcuts) {
        keyedShortcuts[hashShortcut(shortcut)] = shortcut.name;
      }

      function onKeyDown(e) {
        const name = keyedShortcuts[hashShortcut(e)];
        //console.log(e, name)
        if (name) {
          e.preventDefault();
          e.stopPropagation();
          model.send_msg(name);
          return;
        }
      }

      /* bdl: I added capture:true */
      React.useEffect(() => {
        window.addEventListener('keydown', onKeyDown, {capture: true});
        return () => {
          window.removeEventListener('keydown', onKeyDown);
        };
      });

      return <></>;
    }
    """


import time
import itertools
import threading
import os

import panel as pn
import panel.io
import plotly.graph_objects as go
import bokeh.models

import layout as lt
import ui
import util
import test_ui


def wrap(s):
    return pn.widgets.StaticText(value=s)


def latex(s):
    if isinstance(s, str):
        return pn.pane.LaTeX(f"${s}$")
    return s


def row(ls):
    # TODO: look into baseline alignment
    items = [pn.widgets.StaticText(value=l) if isinstance(l, str) else l for l in ls]
    return pn.Row(*items)


def grid(grid_content):

    # this was automatically generated by ChatGPT translating the Dash version
    # TODO: look into alignment etc.

    n_rows = len(grid_content)
    n_cols = max(len(r) for r in grid_content) if n_rows > 0 else 0

    # Flatten children and convert strings
    children = []
    for r in grid_content:
        for cell in r:
            if isinstance(cell, str):
                children.append(pn.widgets.StaticText(value=cell))
            else:
                children.append(cell)

    # Panel GridBox uses ncols; we can approximate the same behavior
    gb = pn.GridBox(
        *children,
        ncols=n_cols,
        #sizing_mode="fixed",  # helps avoid over-expanding horizontally
    )
    gb.css_classes = ["m-grid"]

    # Wrap in a Row (similar to ipw.HBox) to keep width under control
    layout = pn.Row(gb)
    return layout


def graph(figure, height):

    plot = pn.pane.Plotly(
        figure,
        #config={"displayModeBar": False}, # TODO: do we still want this?
        height=int(height),
        css_classes = ["m-plot"]
    )
    return plot

    # TODO: look into plot baseline alignment
    #center_baseline = pn.Spacer(width=0, height=int(height / 2))
    #layout = pn.Row(center_baseline, plot)
    #return layout


def manipulate(init_target_layout, sliders, eval_and_layout):

    # wrap plotly figures in pn.pane.Plotly for more efficient updates
    # else just use a Column (TODO: any better way in this case?)
    def wrap(x):
        if isinstance(x, pn.pane.Plotly):
            return x
        elif isinstance(x, go.Figure):
            return pn.pane.Plotly(x)
        else:
            return pn.Column(x)

    # update the layout depending on how we wrapped it
    # and how we're updating it
    def update(x, v):
        if isinstance(x, pn.pane.Plotly):
            if isinstance(x, pn.pane.Plotly):
                x.object = v.object
            elif isinstance(v, go.Figure):
                x.object = v
        elif isinstance(x, pn.Column):
            x[0] = v

    # state for "debouncing" slider updates so that if they come in
    # faster than we can process them we coalesce consecutive slider events
    update_lock = threading.Lock()
    update_running = False
    update_requested = False
    update_last = None
    update_interval_min = float("inf")

    # called on each slider event (on the main thread)
    # if an update is already running, we just set the update_requested flag,
    # and the running update will see it and schedule another update
    # otherwise we schdule the update ourselves
    def request_update(self):
        nonlocal update_running
        nonlocal update_requested
        with update_lock:
            if update_running:
                request_update = True
                return
            update_running = True
        pn.state.execute(run_update)

    def stats():
        nonlocal update_last
        nonlocal update_interval_min
        if update_last:
            update_interval = (time.time() - update_last) * 1000
            update_interval_min = min(update_interval_min, update_interval)
            print(f"update interval: {update_interval:.1f} ms, min {update_interval_min:.1f} ms")
        update_last = time.time()

    # runs in a worker thread managed by panel to perform an update
    # sets the running flag so that new update reequests don't run until we're done
    # when we're done if we see that a new update has been requested we schedule it
    def run_update():
        nonlocal update_running
        stats()
        try:
            with util.Timer("slider update"):
                values = [s.value for s in pn_sliders]                
                target_layout = eval_and_layout(values)
                update(target, target_layout)
        finally:
            with update_lock:
                if not update_requested:
                    update_running = False
                    return
        pn.state.execute(run_update) # if requested

    # build sliders
    pn_sliders = []
    cells = []    
    def add_slider(s):
        label = pn.pane.Str(s.name)
        slider = pn.widgets.FloatSlider(
            name="",
            start=s.lo,
            end=s.hi,
            step=s.step,
            value=s.init,
            show_value=False,
            sizing_mode="stretch_width"
        )
        readout = pn.widgets.StaticText(value=f"{slider.value:.2f}")

        # keep target in sync with slider
        slider.param.watch(request_update, "value")

        # keep readout in sync with slider
        def update_readout(event):
            readout.value = f"{event.new:.2f}"
        slider.param.watch(update_readout, "value")

        # add to grid
        cells.extend([label, slider, readout])
        pn_sliders.append(slider)

    for s in sliders:
        add_slider(s)

    grid = pn.GridBox(
        *cells,
        ncols=3,
        sizing_mode="stretch_width",
        css_classes=["m-sliders"],
    )

    # wrap the layout for efficient update
    target = wrap(init_target_layout)

    # main layout: target on top, sliders below
    layout = pn.Column(
        target,
        grid,
        width_policy="min",
        css_classes = ["m-manipulate"]
    )

    return layout


# helper for defining buttons with tooltip descripton
# TODO: move to ui.py
def icon_button(icon, description, on_click):
    def tt():
        return bokeh.models.Tooltip(
            content=description,
            position="bottom",
            show_arrow=False
        )
    button = pn.widgets.ButtonIcon(
        icon = icon,
        description = tt(),
    )
    def intercept(event):
        on_click()
        # this seems to make the tooltip disappear if the button moves
        # otherwise the hover state of the tip doesn't change (html misfeature)
        button.description = tt()
    button.on_click(intercept)
    return button


class FileSelect(pn.GridBox):
    """ UI to navigate directory hierarchy """

    def __init__(self, root_dir, on_select, on_open = lambda _: None):

        self.selector = pn.widgets.MultiSelect(
            size=10,
            value=[],
            # always show scrollbar on MacOS
            # https://stackoverflow.com/questions/7492062
            stylesheets=["""
                ::-webkit-scrollbar {
                  -webkit-appearance: none;
                  width: 7px;
                }
                ::-webkit-scrollbar-thumb {
                  border-radius: 4px;
                  background-color: rgba(0, 0, 0, .5);
                  box-shadow: 0 0 1px rgba(255, 255, 255, .5);
                }
            """]
        )

        def on_double_click(event):
            #print("xxx self.selector.value", self.selector.value)
            is_file, path = self.selector.value[0]
            if is_file:
                on_open(path)
            else:
                self.selector.load_dir(root_dir, path)

        super().__init__(
            self.selector,
            ncols=2
        )

        self.selector.on_double_click(on_double_click)
        self.selector.param.watch(lambda _: on_select(), "value")
        self.load_dir(root_dir, root_dir)
    
    def load_dir(self, root_dir, dn):
        folder = "\U0001F4C1 "
        options = {}
        if dn != root_dir:
            options[folder + ".."] = False, os.path.dirname(dn)
        for fn in os.listdir(dn):
            path = os.path.join(dn, fn)
            if fn.startswith(".") or fn.endswith("~"):
                continue
            if os.path.isdir(path):
                name = folder + fn
                value = False, path
            else:
                name = fn
                value = True, path
            options[name] = value
        sorted_items = sorted(options.items(), key=lambda item: item[1])
        options = dict(sorted_items)
        self.selector.options = options
        self.selector.current_dir = dn

    @property
    def info(self):
        value = self.selector.value[0] if len(self.selector.value) else (None, None)
        return value

class OpenFile(pn.Row):
    """ UI to open a file """
    
    def __init__(self, root_dir: str, on_open):
        self.root_dir = root_dir
        self.on_open = on_open

        def on_select():
            _, path = file_select.info
            open_button.disabled = path is None

        def on_open_button(_):
            _, path = file_select.info
            on_open(path)

        super().__init__(
            file_select := FileSelect(root_dir, on_select, on_open),
            open_button := pn.widgets.Button(name="Open"),
            stylesheets = ["""
                :host {
                    gap: 1em;
                }
            """],
            #css_classes = ["m-open-file"] # ugh, can't make it work
        )

        open_button.on_click(on_open_button)

        test_ui.item(file_select.selector, "open_file_select")
        test_ui.item(open_button, "open_file_open_button")


class SaveFile(pn.Row):

    def __init__(self, current_fn, root_dir: str, on_save):
        """ UI to save a file """

        def allowed(path):
            if not path.startswith(root_dir) or ".." in path:
                return False
            else:
                dn = os.path.dirname(path)
                if not os.path.isdir(dn):
                    return False
            return True

        def vet(is_file, path):
            if not path or not is_file:
                disabled, caption = True, "Nope"
            elif not allowed(path):
                disabled, caption = True, "Nope"
            elif path == current_fn:
                disabled, caption = False, "Save"
            elif os.path.exists(path):
                disabled, caption = False, "Overwrite"
            else:
                disabled, caption = False, "Save as"
            save_button.name = caption
            save_button.disabled = disabled
            if path:
                text_input.value = path

        def on_select():
            is_file, path = file_select.info
            vet(is_file, path)

        def on_input(event):
            path = text_input.value_input
            is_file = not os.path.isdir(path)
            vet(is_file, path)

        def on_save_button(event):
            # .value_input is only set after some input
            path = text_input.value_input or text_input.value
            on_save(path)

        super().__init__(
            file_select := FileSelect(root_dir, on_select),
            pn.Column (
                text_input := pn.widgets.TextInput(value=current_fn),
                save_button := pn.widgets.Button(name="Save"),
            ),
            stylesheets = ["""
                :host, * {
                    gap: 1em;
                }
            """],
            #css_classes = ["m-open-file"] # ugh, can't make it work
        )

        save_button.on_click(on_save_button)
        text_input.param.watch(on_input, "value_input")

        test_ui.item(file_select.selector, "save_file_select")
        test_ui.item(text_input, "save_file_text_input")
        test_ui.item(save_button, "save_file_save_button")



#
#
#

class Stack(pn.Column):
    """
    Manages a fixed set of items at the top of the column,
    and a dynamically instantiated set of items,
    only one of which is visible at a time.
    """

    def __init__(self, *fixed, **kwargs):
        """
        Initialize with a fixed set of items, and kwargs passed to super()
        Fixed items are always visible.
        """
        super().__init__(*fixed, **kwargs)
        self.funs = {}
        self.items = {}
        self.active_mode = None
        self.active_item = None

    def append(self, mode, fun):
        """
        Add a dymanic item. Will be instantiated by calling fun()
        when it is activated.
        """
        self.funs[mode] = fun
        self.items[mode] = None

    def activate(self, mode):
        """
        Activate a dynamic item by name by making it visible
        """
        item = self.items[mode]
        if not item:
            item = self.funs[mode]()
            if not item:
                return
            self.items[mode] = item
            super().append(item)
        if self.active_item:
            self.active_item.visible = False
        item.visible = True
        self.active_item = item
        self.active_mode = mode

    def close(self, mode):
        if mode in self.items:
            item = self.items[mode]
            self.remove(item)
            self.items[mode] = None
            
    def close_item(self, item):
        ...

#
# Following code is from https://github.com/holoviz/panel/issues/3193
#

from typing import TypedDict, NotRequired
from panel.custom import ReactComponent, DataEvent
import param
import panel as pn


# Note: this uses TypedDict instead of Pydantic or dataclass because Bokeh/Panel doesn't seem to
# like serializing custom classes to the frontend (and I can't figure out how to customize that).
class KeyboardShortcut(TypedDict):
    name: str
    key: str
    altKey: NotRequired[bool]
    ctrlKey: NotRequired[bool]
    metaKey: NotRequired[bool]
    shiftKey: NotRequired[bool]


class KeyboardShortcuts(ReactComponent):
    """
    Class to install global keyboard shortcuts into a Panel app.

    Pass in shortcuts as a list of KeyboardShortcut dictionaries, and then handle shortcut events in Python
    by calling `on_msg` on this component. The `name` field of the matching KeyboardShortcut will be sent as the `data`
    field in the `DataEvent`.

    Example:
    >>> shortcuts = [
        KeyboardShortcut(name="save", key="s", ctrlKey=True),
        KeyboardShortcut(name="print", key="p", ctrlKey=True),
    ]
    >>> shortcuts_component = KeyboardShortcuts(shortcuts=shortcuts)
    >>> def handle_shortcut(event: DataEvent):
            if event.data == "save":
                print("Save shortcut pressed!")
            elif event.data == "print":
                print("Print shortcut pressed!")
    >>> shortcuts_component.on_msg(handle_shortcut)
    """

    # bdl - following failed, but my change works
    #shortcuts = param.List(class_=dict)
    shortcuts = param.List()

    _esm = """
    // Hash a shortcut into a string for use in a dictionary key (booleans / null / undefined are coerced into 1 or 0)
    function hashShortcut({ key, altKey, ctrlKey, metaKey, shiftKey }) {
      return `${key}.${+!!altKey}.${+!!ctrlKey}.${+!!metaKey}.${+!!shiftKey}`;
    }

    export function render({ model }) {
      const [shortcuts] = model.useState("shortcuts");

      const keyedShortcuts = {};
      for (const shortcut of shortcuts) {
        keyedShortcuts[hashShortcut(shortcut)] = shortcut.name;
      }

      function onKeyDown(e) {
        const name = keyedShortcuts[hashShortcut(e)];
        //console.log(e, name)
        if (name) {
          e.preventDefault();
          e.stopPropagation();
          model.send_msg(name);
          return;
        }
      }

      /* bdl: I added capture:true */
      React.useEffect(() => {
        window.addEventListener('keydown', onKeyDown, {capture: true});
        return () => {
          window.removeEventListener('keydown', onKeyDown);
        };
      });

      return <></>;
    }
    """


import time
import itertools
import threading
import os

import panel as pn
import panel.io
import plotly.graph_objects as go
import bokeh.models

import layout as lt
import ui
import util
import test_ui


def wrap(s):
    return pn.widgets.StaticText(value=s)


def latex(s):
    if isinstance(s, str):
        return pn.pane.LaTeX(f"${s}$")
    return s


def row(ls):
    # TODO: look into baseline alignment
    items = [pn.widgets.StaticText(value=l) if isinstance(l, str) else l for l in ls]
    return pn.Row(*items)


def grid(grid_content):

    # this was automatically generated by ChatGPT translating the Dash version
    # TODO: look into alignment etc.

    n_rows = len(grid_content)
    n_cols = max(len(r) for r in grid_content) if n_rows > 0 else 0

    # Flatten children and convert strings
    children = []
    for r in grid_content:
        for cell in r:
            if isinstance(cell, str):
                children.append(pn.widgets.StaticText(value=cell))
            else:
                children.append(cell)

    # Panel GridBox uses ncols; we can approximate the same behavior
    gb = pn.GridBox(
        *children,
        ncols=n_cols,
        #sizing_mode="fixed",  # helps avoid over-expanding horizontally
    )
    gb.css_classes = ["m-grid"]

    # Wrap in a Row (similar to ipw.HBox) to keep width under control
    layout = pn.Row(gb)
    return layout


def graph(figure, height):

    plot = pn.pane.Plotly(
        figure,
        #config={"displayModeBar": False}, # TODO: do we still want this?
        #height=int(height),
        css_classes = ["m-plot"]
    )
    return plot

    # TODO: look into plot baseline alignment
    #center_baseline = pn.Spacer(width=0, height=int(height / 2))
    #layout = pn.Row(center_baseline, plot)
    #return layout


def manipulate(init_target_layout, sliders, eval_and_layout):

    # wrap plotly figures in pn.pane.Plotly for more efficient updates
    # else just use a Column (TODO: any better way in this case?)
    def wrap(x):
        if isinstance(x, pn.pane.Plotly):
            return x
        elif isinstance(x, go.Figure):
            return pn.pane.Plotly(x)
        else:
            return pn.Column(x)

    # update the layout depending on how we wrapped it
    # and how we're updating it
    def update(x, v):
        if isinstance(x, pn.pane.Plotly):
            if isinstance(x, pn.pane.Plotly):
                x.object = v.object
            elif isinstance(v, go.Figure):
                x.object = v
        elif isinstance(x, pn.Column):
            x[0] = v

    # state for "debouncing" slider updates so that if they come in
    # faster than we can process them we coalesce consecutive slider events
    update_lock = threading.Lock()
    update_running = False
    update_requested = False
    update_last = None
    update_interval_min = float("inf")

    # called on each slider event (on the main thread)
    # if an update is already running, we just set the update_requested flag,
    # and the running update will see it and schedule another update
    # otherwise we schdule the update ourselves
    def request_update(self):
        nonlocal update_running
        nonlocal update_requested
        with update_lock:
            if update_running:
                request_update = True
                return
            update_running = True
        pn.state.execute(run_update)

    def stats():
        nonlocal update_last
        nonlocal update_interval_min
        if update_last:
            update_interval = (time.time() - update_last) * 1000
            update_interval_min = min(update_interval_min, update_interval)
            print(f"update interval: {update_interval:.1f} ms, min {update_interval_min:.1f} ms")
        update_last = time.time()

    # runs in a worker thread managed by panel to perform an update
    # sets the running flag so that new update reequests don't run until we're done
    # when we're done if we see that a new update has been requested we schedule it
    def run_update():
        nonlocal update_running
        stats()
        try:
            with util.Timer("slider update"):
                values = [s.value for s in pn_sliders]                
                target_layout = eval_and_layout(values)
                update(target, target_layout)
        finally:
            with update_lock:
                if not update_requested:
                    update_running = False
                    return
        pn.state.execute(run_update) # if requested

    # build sliders
    pn_sliders = []
    cells = []    
    def add_slider(s):
        label = pn.pane.Str(s.name)
        slider = pn.widgets.FloatSlider(
            name="",
            start=s.lo,
            end=s.hi,
            step=s.step,
            value=s.init,
            show_value=False,
            sizing_mode="stretch_width"
        )
        readout = pn.widgets.StaticText(value=f"{slider.value:.2f}")

        # keep target in sync with slider
        slider.param.watch(request_update, "value")

        # keep readout in sync with slider
        def update_readout(event):
            readout.value = f"{event.new:.2f}"
        slider.param.watch(update_readout, "value")

        # add to grid
        cells.extend([label, slider, readout])
        pn_sliders.append(slider)

    for s in sliders:
        add_slider(s)

    grid = pn.GridBox(
        *cells,
        ncols=3,
        sizing_mode="stretch_width",
        css_classes=["m-sliders"],
    )

    # wrap the layout for efficient update
    target = wrap(init_target_layout)

    # main layout: target on top, sliders below
    layout = pn.Column(
        target,
        grid,
        width_policy="min",
        css_classes = ["m-manipulate"]
    )

    return layout


# helper for defining buttons with tooltip descripton
# TODO: move to ui.py
def icon_button(icon, description, on_click):
    def tt():
        return bokeh.models.Tooltip(
            content=description,
            position="bottom",
            show_arrow=False
        )
    button = pn.widgets.ButtonIcon(
        icon = icon,
        description = tt(),
    )
    def intercept(event):
        on_click()
        # this seems to make the tooltip disappear if the button moves
        # otherwise the hover state of the tip doesn't change (html misfeature)
        button.description = tt()
    button.on_click(intercept)
    return button


class FileSelect(pn.GridBox):
    """ UI to navigate directory hierarchy """

    def __init__(self, init_path, update_button, on_action, double_click_allowed):

        if init_path is None:
            init_path = os.getcwd()
        init_path = os.path.abspath(init_path)
        if os.path.isdir(init_path):
            init_dir = init_path
            init_fn = ""
        else:
            init_dir, init_fn = os.path.split(init_path)

        def on_double_click(event):
            path = self.selector.value[0]
            if os.path.isdir(path):
                self.load_dir(path)
                update_button(path)
            elif double_click_allowed:
                print(f"on_action {self.selected_path}")
                on_action(self.selected_path)

        def _on_select(_):

            def show(fn):
                self.show_fn.value = fn
                self.button.disabled = not fn

            if self.selector.value and self.selector.value[0]:
                path = self.selector.value[0]
                if os.path.isdir(path):
                    show("")
                else:
                    show(os.path.split(path)[-1])
            else:
                show("")

            update_button(self.selected_path)
            
        def on_button_click(_):
            on_action(self.selected_path)

        def on_filename_input(_):
            self.selector.value = [self.selected_path]


        # TODO: following should be StaticText, but this works around an apparent but
        # in Panel where updates to show_dn after the first didn't cause any change
        # IFF there was also a View with a document with a plot loaded (whew!)
        self.show_dn = pn.Row(styles={"padding": "0.4em"}) # TODO: hack to make baseline match TextInput
        self.show_fn = pn.widgets.TextInput()
        self.button = pn.widgets.Button()

        self.selector = pn.widgets.MultiSelect(
            size=10,
            value=[],
            # always show scrollbar on MacOS
            # https://stackoverflow.com/questions/7492062
            stylesheets=["""
                ::-webkit-scrollbar {
                  -webkit-appearance: none;
                  width: 7px;
                }
                ::-webkit-scrollbar-thumb {
                  border-radius: 4px;
                  background-color: rgba(0, 0, 0, .5);
                  box-shadow: 0 0 1px rgba(255, 255, 255, .5);
                }
            """]
        )

        super().__init__(
            self.show_dn,
            self.show_fn,
            self.selector,
            self.button,
            ncols=2,
            styles = {
                "gap": "1em",
                "align-items": "baseine",
            }
        )

        self.selector.on_double_click(on_double_click)
        self.button.on_click(on_button_click)
        self.selector.param.watch(_on_select, "value")
        self.show_fn.param.watch(on_filename_input, "value_input")

        self.load_dir(init_dir)
        self.selector.value = [init_path]
        #update_button(self.selected_path)

    
    def load_dir(self, load_path):

        folder = "\U0001F4C1 "
        options = {}

        # add parent dir
        options[folder + ".."] = os.path.abspath(os.path.join(load_path, ".."))

        # add ls
        for fn in list(os.listdir(load_path)):
            if fn.startswith(".") or fn.endswith("~"):
                continue
            path = os.path.abspath(os.path.join(load_path, fn))
            if os.path.isdir(path):
                options[folder + fn] = path
            else:
                options[fn] = path

        # sort by name, with directories first
        sort_key = lambda item: (not os.path.isdir(item[1]), item[1])
        sorted_items = sorted(options.items(), key=sort_key)
        options = dict(sorted_items)

        # update widgets
        self.selector.options = options
        self.show_dn[:] = [load_path + "/"]
        self.show_fn.value = ""


    @property
    def selected_path(self):
        return str(self.show_dn[0].object) + self.show_fn.value

    @property
    def info(self):
        value = self.selector.value[0] if len(self.selector.value) else (None, None)
        return value


class OpenFile(FileSelect):
    """ UI to open a file """
    
    def __init__(self, init_dir, on_open):

        def update_button(path):
            self.button.name = "Open"

        super().__init__(init_dir, update_button, on_open, double_click_allowed=True)


class SaveFile(FileSelect):
    """ UI to save a file """
    
    def __init__(self, current_fn, init_dir, on_save):

        if current_fn:
            current_fn = os.path.abspath(current_fn)

        def update_button(path):
            if os.path.exists(path) and not os.path.isdir(path) and path != current_fn:
                self.button.name = "Overwrite"
                self.button.button_type = "danger"
            else:
                self.button.name = "Save"
                self.button.button_type = "default"

        super().__init__(current_fn, update_button, on_save, double_click_allowed=False)



#
#
#

class Stack(pn.Column):
    """
    Manages a fixed set of items at the top of the column,
    and a dynamically instantiated set of items,
    only one of which is visible at a time.
    """

    def __init__(self, *fixed, **kwargs):
        """
        Initialize with a fixed set of items, and kwargs passed to super()
        Fixed items are always visible.
        """
        super().__init__(*fixed, **kwargs)
        self.funs = {}
        self.items = {}
        self.active_mode = None
        self.active_item = None

    def append(self, mode, fun):
        """
        Add a dymanic item. Will be instantiated by calling fun()
        when it is activated.
        """
        self.funs[mode] = fun
        self.items[mode] = None

    def activate(self, mode):
        """
        Activate a dynamic item by name by making it visible
        """
        item = self.items[mode]
        if not item:
            item = self.funs[mode]()
            if not item:
                return
            self.items[mode] = item
            super().append(item)
        if self.active_item:
            self.active_item.visible = False
        item.visible = True
        self.active_item = item
        self.active_mode = mode

    def close(self, mode):
        if mode in self.items:
            item = self.items[mode]
            self.remove(item)
            self.items[mode] = None
            
    def close_item(self, item):
        self.remove(item)
        modes = [mode for mode, i in self.items.items() if i==item]
        assert len(modes)== 1
        self.items[modes[0]] = None

#
# Following code is from https://github.com/holoviz/panel/issues/3193
#

from typing import TypedDict, NotRequired
from panel.custom import ReactComponent, DataEvent
import param
import panel as pn


# Note: this uses TypedDict instead of Pydantic or dataclass because Bokeh/Panel doesn't seem to
# like serializing custom classes to the frontend (and I can't figure out how to customize that).
class KeyboardShortcut(TypedDict):
    name: str
    key: str
    altKey: NotRequired[bool]
    ctrlKey: NotRequired[bool]
    metaKey: NotRequired[bool]
    shiftKey: NotRequired[bool]


class KeyboardShortcuts(ReactComponent):
    """
    Class to install global keyboard shortcuts into a Panel app.

    Pass in shortcuts as a list of KeyboardShortcut dictionaries, and then handle shortcut events in Python
    by calling `on_msg` on this component. The `name` field of the matching KeyboardShortcut will be sent as the `data`
    field in the `DataEvent`.

    Example:
    >>> shortcuts = [
        KeyboardShortcut(name="save", key="s", ctrlKey=True),
        KeyboardShortcut(name="print", key="p", ctrlKey=True),
    ]
    >>> shortcuts_component = KeyboardShortcuts(shortcuts=shortcuts)
    >>> def handle_shortcut(event: DataEvent):
            if event.data == "save":
                print("Save shortcut pressed!")
            elif event.data == "print":
                print("Print shortcut pressed!")
    >>> shortcuts_component.on_msg(handle_shortcut)
    """

    # bdl - following failed, but my change works
    #shortcuts = param.List(class_=dict)
    shortcuts = param.List()

    _esm = """
    // Hash a shortcut into a string for use in a dictionary key (booleans / null / undefined are coerced into 1 or 0)
    function hashShortcut({ key, altKey, ctrlKey, metaKey, shiftKey }) {
      return `${key}.${+!!altKey}.${+!!ctrlKey}.${+!!metaKey}.${+!!shiftKey}`;
    }

    export function render({ model }) {
      const [shortcuts] = model.useState("shortcuts");

      const keyedShortcuts = {};
      for (const shortcut of shortcuts) {
        keyedShortcuts[hashShortcut(shortcut)] = shortcut.name;
      }

      function onKeyDown(e) {
        const name = keyedShortcuts[hashShortcut(e)];
        //console.log(e, name)
        if (name) {
          e.preventDefault();
          e.stopPropagation();
          model.send_msg(name);
          return;
        }
      }

      /* bdl: I added capture:true */
      React.useEffect(() => {
        window.addEventListener('keydown', onKeyDown, {capture: true});
        return () => {
          window.removeEventListener('keydown', onKeyDown);
        };
      });

      return <></>;
    }
    """

